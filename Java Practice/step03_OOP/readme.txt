학습내용

*객체 생성이란?
 - 보유하고 있는 모든 멤버 변수들이 완벽히 메모리에 생성되어야만 생성자 실행 종료

1. 상속과 다형성
 	- 필요성 : 코드의 재사용성 증대, 타입의 무한 사용
 	- 기업 관점 : 개발 및 유지보수 비용 절감
2. 상속과 다형성의 중요성
	1) 이해 못하면 외부 코드 분석 불가
	2) API에 대한 사용을 위해서도 필요한 메커니즘
3. 개념
	1. 상속
		- 조상 또는 부모로부터 변수, 메소드는 상속
		- 부모 생성자는 절대 자식 클래스에서 상속 불가
			(단, 자식에서는 부모의 생성자 호출은 가능)
		- static{} 상속 불가, 자식 클래스에서 호출도 불가능
	2. 상속 받은 메소드의 내용은 수정 가능
		- 재정의(overriding=override)
		- 상속받은 메소드의 선언구는 부모와 동일하게, 단 {body}부분만 다르게
	3. 다형성
	 1) (중요) 상속 관계가 전제가 된 상태에서만 다형성 성립
	 2) 하나의 타입이 여러 타입의 객체를 보유할 수 있는 이론
	   - 하나의 타입 : 부모 또는 조상
	   - 여러 타입 : 자식 또는 자손
	 
	 
4. 핵심 내용
	1) 모든 클래스는 java.lang.Object 상속
	2) class 선언구에 상속 문구가 없을 경우 컴파일러가 자동 추가함
		- java.lang.Object 상속받는 코드 자동 추가 (문법 : extends Object)
		- 예외 : 개발자들이 명시적으로 상속관계 코드를 작성할 경우는 절대 자동 추가되지 않음
		
5. 문법
	1. 상속
		class 자식클래스명 extends 부모클래스명{}
	2. 부모 생성자 호출
	 	super([..]);
	 	- super : 부모/sub : 자식
	 	- parent : 부모/child : 자식
	 	- 고려사항 - 자식 생성자에서 왜 super([..]); 로 부모 생성자 호출?
	 	- jdk자체를 설계한 사람 관점
	 		- 자바 언어로 개발하는 모든 클래스명
	 		  super() 문법으로 모든 부모 인식을 쉽고 명확하게 하기 위함
	 3. 다형성 문법
	 	부모(조상) 타입 변수 = new 자식(자손) 생성자([...]);    (생성자 호출 -> 객체 생성)
	 	
6. 주요 키워드
	1) this
	 1-1] this. : 생성자 또는 메소드 내부에서 로컬 변수와 멤버 변수명이 동일할 때, 멤버 변수 구분하고자 할때 사용
	 	  this.name = name; (좌변 : 클래스의 멤버, 우변 : 로컬변수)
	 1-2] this() : 하나의 클래스에서 다수의 생성자 개발했을 경우 다른 생성자를 호출할 때 사용하는 문장
	 	  A(){
	 	  	this("string");
	 	  	}
	 	  	A(String s){   string 자기 자신을 가진 메소드를 또 만드는...
	 	  	 super();
	 	  	 
	2) super
	 2-1] super.
	 	- 메소드를 재정의(overriding, override) 할 때 부모의 메소드 로직을 100% 반영하고자 할 때 사용
	 
	 2-2] super([..])
	 	- 자식 생성자가 부모 생성자 호출 시 사용되는 문법
	 	- * 생성자마다 자동 추가, 생성자의 첫 라인에 추가
	 		: 예외 - 단, this()가 존재할 경우에만 자동 추가 불가
	 		
7. 상속과 다형성 연관된 메소드 고려하기
	1. java.lang.Object의 toString()
		- 생성된 객체의 주소값을 문자열로 반환
		- API상에 이미 존재하는 다수의 하위 클래스는 이미 내용값 반환으로 재정의되어있음
		- 데이터 표현(DTO=VO=bean)용 클래스에서는 내용값 반환하게끔 재정의를 해놓음 (그래서 여기에서 toString을 만듬)
		
	2. java.lang.Object의 equals()
		- 생성된 객체의 주소값 비교
		- 일반적으로 == 이라는 연산자로 대체해서 사용
		   자식 클래스에선 가급적 동일한 타입의 서로 다른 객체들의 데이터값을 비교할 수 있게 재정의
		  